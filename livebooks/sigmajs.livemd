<!-- livebook:{"app_settings":{"access_type":"public","show_source":true,"slug":"iroh-observer"}} -->

# Graphviz Observer

```elixir
Mix.install([
  {:kino, "~> 0.15.3"},
  {:iroh_ex, "~> 0.0.5"},
  {:rustler, "~> 0.36.1", override: true},
  {:rustler_precompiled, "~> 0.7"}
])
```

## Livebook Sigma

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
defmodule SigmaGraph do
  use Kino.JS
  use Kino.JS.Live

  def new do
    Kino.JS.Live.new(__MODULE__, %{})
  end

  # Add a node
  def add_node(kino, node, replace \\ false) do
    Kino.JS.Live.cast(kino, {:add_node, node, replace})
  end

  def merge_node(kino, node) do
    Kino.JS.Live.cast(kino, {:merge_node, node})
  end

  # Remove a node
  def remove_node(kino, node_id) do
    Kino.JS.Live.cast(kino, {:remove_node, node_id})
  end

  # Add an edge
  def add_edge(kino, edge) do
    Kino.JS.Live.cast(kino, {:add_edge, edge})
  end

  # Add an edge without rendering
  def add_edge_batched(kino, edge) do
    Kino.JS.Live.cast(kino, {:add_edge_batched, edge})
  end

  # Remove an edge
  def remove_edge(kino, edge) do
    Kino.JS.Live.cast(kino, {:remove_edge, edge})
  end

  def render(kino) do
    Kino.JS.Live.cast(kino, :render)
  end

  def clear(kino) do
    Kino.JS.Live.cast(kino, :clear)
  end

  def test(kino, payload) do
    Kino.JS.Live.cast(kino, {:test, payload})
  end

  @impl true
  def init(_, ctx) do
    {:ok, assign(ctx, nodes: %{}, edges: [])}
  end

  @impl true
  def handle_connect(ctx) do
    {:ok, ctx.assigns, ctx}
  end

  @impl true
  def handle_cast({:test, payload}, ctx) do
    # IO.inspect(payload, label: "Test")
    broadcast_event(ctx, "test", payload)
    {:noreply, ctx}
  end

  @impl true
  def handle_cast(:clear, ctx) do
    # IO.inspect(payload, label: "Test")
    broadcast_event(ctx, "clear", [])
    {:noreply, ctx}
  end

  @impl true
  def handle_cast({:add_node, node, replace}, ctx) do
    default_values = %{
      x: :rand.uniform(10),
      y: :rand.uniform(10),
      size: 10,
      color: "#1f77b4"
    }

    node = Map.merge(default_values, node)

    # IO.inspect(node, label: "Node debug")

    ctx = update_in(ctx.assigns.nodes, &Map.put(&1, node.id, node))
    # IO.inspect(node, label: "Add Node")
    # IO.inspect(ctx, label: "Add Node ctx")
    broadcast_event(
      ctx,
      "add_node",
      node |> Map.put(:replace, replace)
    )

    {:noreply, ctx}
  end

  @impl true
  def handle_cast({:merge_node, node}, ctx) do
    ctx =
      update_in(ctx.assigns.nodes, fn nodes ->
        Map.update(nodes, node.id, node, &Map.merge(&1, node))
      end)

    broadcast_event(
      ctx,
      "merge_node",
      node
    )

    {:noreply, ctx}
  end

  @impl true
  def handle_cast({:add_edge, edge}, ctx) do
    ctx = update_in(ctx.assigns.edges, &[edge | &1])
    broadcast_event(ctx, "add_edge", edge)
    {:noreply, ctx}
  end

  @impl true
  def handle_cast({:add_edge_batched, edge}, ctx) do
    ctx = update_in(ctx.assigns.edges, &[edge | &1])
    broadcast_event(ctx, "add_edge_batched", edge)
    {:noreply, ctx}
  end

  @impl true
  def handle_cast(:render, ctx) do
    broadcast_event(ctx, "render", [])
    {:noreply, ctx}
  end

  @impl true
  def handle_cast({:remove_node, node_id}, ctx) do
    ctx = update_in(ctx.assigns.nodes, &Map.delete(&1, node_id))

    # Correctly filter out edges that involve the removed node
    ctx =
      update_in(
        ctx.assigns.edges,
        &Enum.reject(&1, fn edge ->
          edge.source == node_id || edge.target == node_id
        end)
      )

    broadcast_event(ctx, "remove_node", node_id)
    {:noreply, ctx}
  end

  @impl true
  def handle_cast({:remove_edge, edge}, ctx) do
    ctx =
      update_in(
        ctx.assigns.edges,
        &Enum.reject(&1, fn e ->
          edge.source == e.source && edge.target == e.target
        end)
      )

    broadcast_event(ctx, "remove_edge", edge)
    {:noreply, ctx}
  end

  @impl true
  def handle_info(msg, ctx) do
    IO.puts("#{__MODULE__} Catchall #{inspect(msg)}")
    {:noreply, ctx}
  end

  asset "main.js" do
    """
    import Sigma from 'https://cdn.jsdelivr.net/npm/sigma@3.0.1/+esm';
    import Graph from 'https://cdn.jsdelivr.net/npm/graphology@0.26.0/+esm';
    import graphologyLayout from 'https://cdn.jsdelivr.net/npm/graphology-layout@0.6.1/+esm';
    import FA2Layout from 'https://cdn.jsdelivr.net/npm/graphology-layout-forceatlas2@0.10.1/+esm';
    import graphOlogyLayoutForce from 'https://cdn.jsdelivr.net/npm/graphology-layout-force@0.2.4/+esm';
    import sigmaEdgeCurve from 'https://cdn.jsdelivr.net/npm/@sigma/edge-curve@3.1.0/+esm';
    import debounce from 'https://cdn.jsdelivr.net/npm/debounce@2.2.0/+esm';

    const { circular } = graphologyLayout;

    export function init(ctx, payload) {
      const container = document.createElement("div");
      container.style.width = "100%";
      container.style.height = "500px";
      ctx.root.appendChild(container);

      const graph = new Graph();
      const renderer = new Sigma(graph, container, {
        labelDensity: 0.2,
        labelRenderedSizeThreshold: 10,
        defaultLabelSize: 14,
        edgeProgramClasses: {
          curved: sigmaEdgeCurve,
        },
      });

      // Store full labels separately
      const fullLabels = {};

      function placeNodesInRing(centerX, centerY, radius) {
          const ringNodes = graph.nodes().filter(n => graph.getNodeAttribute(n, "layout") === "ring");
          const angleStep = (2 * Math.PI) / ringNodes.length; // Evenly distribute

          ringNodes.forEach((node, i) => {
              const angle = i * angleStep;
              graph.mergeNodeAttributes(node, {
                  x: centerX + radius * Math.cos(angle),
                  y: centerY + radius * Math.sin(angle),
              });
          });
      }

      function placeNodesInGrid(gridStartX, gridStartY, cols, spacing) {
          const gridNodes = graph.nodes().filter(n => graph.getNodeAttribute(n, "layout") === "grid");

          gridNodes.forEach((node, i) => {
              const row = Math.floor(i / cols);
              const col = i % cols;
              graph.mergeNodeAttributes(node, {
                  x: gridStartX + col * spacing, // Column placement
                  y: gridStartY + row * spacing, // Row placement
              });
          });
      }

      function render() {
        adjustLabelPositions();
        renderer.refresh();
      }

      function formatLabel(label) {
        return label.length > 20 ? label.substring(0, 20) + "..." : label;
      }

      function adjustLabelPositions() {
        graph.updateEachNodeAttributes((node, attr) => ({
          ...attr,
          labelY: attr.y + 0.2,  // Move label slightly outside the node
        }));
      }

      ctx.handleEvent("clear", (n) => {
        graph.clear();
        renderer.refresh();
      });

      ctx.handleEvent("add_node", (node) => {
        console.log("Add node", node);

        if (node.replace || !graph.hasNode(node.id)) {
          if (node.replace && graph.hasNode(node.id)) {
            graph.dropNode(node.id);
          }

          fullLabels[node.id] = node.label;

          graph.addNode(node.id, node);

          // placeNodesInRing(centerX, centerY, radius)
          if(node.layout == 'ring') placeNodesInRing(0, 0, 10); // circular.assign(graph);
          // placeNodesInGrid(gridStartX, gridStartY, cols, spacing)
          if(node.layout == 'grid') placeNodesInGrid(20, -10, 4, 1);

        } else {
          console.log("Node " + node.id + " already exists, ignore");
        }

        debounce(render, 100);
      });

      ctx.handleEvent("merge_node", (node) => {
        console.log("Merge node", node);

        if (graph.hasNode(node.id)) {
          graph.mergeNode(node.id, node);
          fullLabels[node.id] = node.label;
          adjustLabelPositions();
          debounce(render, 100);
        }
      });

      ctx.handleEvent("remove_node", (nodeId) => {
        if (graph.hasNode(nodeId)) {
          graph.dropNode(nodeId);
          delete fullLabels[nodeId];
        }
        debounce(render, 100);
      });

      ctx.handleEvent("add_edge", ({ source, target, props }) => {
        if (graph.hasNode(source) && graph.hasNode(target)) {
          if( graph.hasEdge(source, target) ) graph.dropEdge(source, target);
          graph.addEdge(source, target, props);
        } 
        debounce(render, 100);
      });

      ctx.handleEvent("add_edge_batched", ({ source, target, props }) => {
        if (graph.hasNode(source) && graph.hasNode(target) && !graph.hasEdge(source, target)) {
          graph.addEdge(source, target, props);
        }
      });

      ctx.handleEvent("render", (ctx) => {
        renderer.refresh();
      });

      ctx.handleEvent("remove_edge", ({ source, target }) => {
        if (graph.hasEdge(source, target)) {
          graph.dropEdge(source, target);
        }
        renderer.refresh();
      });

      // Show full label on hover
      renderer.on("enterNode", ({ node }) => {
        graph.setNodeAttribute(node, "label", fullLabels[node]);
        renderer.refresh();
      });

      // Restore shortened label when mouse leaves
      renderer.on("leaveNode", ({ node }) => {
        graph.setNodeAttribute(node, "label", formatLabel(fullLabels[node]));
        renderer.refresh();
      });
    }

    """
  end
end
```

## Process Observer

```elixir
defmodule ProcessMonitor do
  use GenServer

  # Starts the GenServer and initiates tracing
  def start_link(graph) do
    case Process.whereis(__MODULE__) do
      nil ->
        IO.puts("#{__MODULE__} No Process running")
        SigmaGraph.add_node(graph, %{id: "Status", label: "No Process running"}, true)
        GenServer.start_link(__MODULE__, graph, name: __MODULE__)
        SigmaGraph.add_node(graph, %{id: "Status", label: "Process started"}, true)

      pid when is_pid(pid) ->
        IO.puts("#{__MODULE__} Process already running #{inspect(pid)}")
        Process.exit(pid, :kill)
        SigmaGraph.add_node(graph, %{id: "Status", label: "Killing existing Process"}, true)
        # Wait a moment to ensure the process exits
        Process.sleep(100)
        GenServer.start_link(__MODULE__, graph, name: __MODULE__)
        SigmaGraph.add_node(graph, %{id: "Status", label: "Process started"}, true)
    end
  end

  @impl true
  def init(graph) do
    # Set up tracing for all processes
    IO.inspect(graph, label: "Init ProcessMonitor")
    :erlang.trace(:all, true, [:procs])
    {:ok, %{graph: graph}}
  end

  defp format_pid(pid) do
    formatted = inspect(pid)
    # |> String.replace("#", "") # Original commented out lines
    # |> String.replace("<", "")
    # |> String.replace(">", "")
    # |> String.replace(".", "")

    formatted

    # IO.inspect(formatted, label: "formatted pid") # Original commented out line
  end

  @impl true
  def handle_info({:trace, pid, :spawn, new_pid, mfa}, %{graph: graph} = state) do
    # IO.inspect(graph, label: "Graph debug") # Original commented out line
    IO.puts("Process #{inspect(new_pid)} spawned by #{inspect(pid)}: #{inspect(mfa)}")

    SigmaGraph.add_node(graph, %{
      id: "#{format_pid(pid)}",
      label: "Process #{format_pid(pid)}, MFA: #{TraceParser.extract_mfa(mfa)}"
    })

    SigmaGraph.add_node(graph, %{
      id: "#{format_pid(new_pid)}",
      label: "Process #{format_pid(new_pid)}, MFA: #{TraceParser.extract_mfa(mfa)}"
    })

    # SigmaGraph.add_edge(graph, %{source: format_pid(pid), target: format_pid(new_pid)}) # Original commented out line
    # {:noreply, state |> Map.put(:graph, graph)} # Original commented out line
    # Original return value
    {:noreply, state}
  end

  def handle_info({:trace, pid, :exit, reason}, %{graph: graph} = state) do
    IO.puts("Process #{inspect(pid)} exited with reason: #{inspect(reason)}")
    SigmaGraph.remove_node(graph, "#{format_pid(pid)}")
    # {:noreply, state |> Map.put(:graph, graph)} # Original commented out line
    # Original return value
    {:noreply, state}
  end

  def handle_info({:trace, pid, :link, linked_pid}, %{graph: graph} = state) do
    IO.puts("Process #{inspect(pid)} linked to #{inspect(linked_pid)}")
    SigmaGraph.add_node(graph, %{id: "#{format_pid(pid)}", label: "Process #{format_pid(pid)}"})

    SigmaGraph.add_node(graph, %{
      id: "#{format_pid(linked_pid)}",
      label: "Process #{format_pid(linked_pid)}"
    })

    SigmaGraph.add_edge(graph, %{
      source: "#{format_pid(pid)}",
      target: "#{format_pid(linked_pid)}"
    })

    # {:noreply, state |> Map.put(:graph, graph)} # Original commented out line
    # Original return value
    {:noreply, state}
  end

  def handle_info({:trace, pid, :unlink, unlinked_pid}, %{graph: graph} = state) do
    IO.puts("Process #{inspect(pid)} unlinked from #{inspect(unlinked_pid)}")

    SigmaGraph.remove_edge(graph, %{
      source: "#{format_pid(pid)}",
      target: "#{format_pid(unlinked_pid)}"
    })

    # {:noreply, state |> Map.put(:graph, graph)} # Original commented out line
    # Original return value
    {:noreply, state}
  end

  def handle_info(msg, state) do
    IO.puts("#{__MODULE__} catchall #{inspect(msg)}")
    {:noreply, state}
  end
end

defmodule TraceParser do
  def extract_mfa({mod, fun, args}) when is_atom(mod) and is_atom(fun) and is_list(args) do
    "#{mod}.#{fun}/#{length(args)}"
  end

  def extract_mfa({:erlang, :apply, [func, _]}) when is_function(func, 0) do
    func_info = inspect(func)

    case String.split(func_info, " in ") do
      [_, mfa] -> mfa
      _ -> "UnknownFunction"
    end
  end

  def extract_mfa(_), do: "UnknownFunction"
end

defmodule Worker do
  use GenServer

  def start_link(_) do
    # Unique name
    GenServer.start_link(__MODULE__, %{}, name: :erlang.make_ref())
  end

  def init(_) do
    # Live for 2-5 seconds
    lifespan = :rand.uniform(3000) + 2000
    Process.send_after(self(), :die, lifespan)
    {:ok, %{}}
  end

  def handle_info(:die, _state) do
    IO.puts("Worker #{inspect(self())} exiting")
    exit(:normal)
  end
end

defmodule WorkerSupervisor do
  use Supervisor

  def start_link(_) do
    Supervisor.start_link(__MODULE__, :ok, name: __MODULE__)
  end

  def init(:ok) do
    children = [
      # Defines a Worker child spec
      {Worker, []}
    ]

    Supervisor.init(children, strategy: :simple_one_for_one)
  end
end

defmodule WorkerManager do
  use GenServer

  def start_link(_) do
    GenServer.start_link(__MODULE__, :ok, name: __MODULE__)
  end

  def init(:ok) do
    # Start workers after a delay
    Process.send_after(self(), :start_workers, :rand.uniform(5000))
    {:ok, %{}}
  end

  def handle_info(:start_workers, state) do
    # 1 to 10 workers
    num_workers = :rand.uniform(10)

    for _ <- 1..num_workers do
      Supervisor.start_child(WorkerSupervisor, [])
    end

    IO.puts("Spawned #{num_workers} workers")

    # Schedule the next batch
    Process.send_after(self(), :start_workers, :rand.uniform(5000))

    {:noreply, state}
  end
end

defmodule SupervisorExample do
  def start_link do
    # Start the Worker Supervisor
    {:ok, _} = WorkerSupervisor.start_link([])

    # Start the Worker Manager
    {:ok, _} = WorkerManager.start_link([])
  end
end
```

## Iroh Observer

```elixir
defmodule IrohObserver do
  use GenServer
  alias IrohEx.Native

  @rand_msg_delay 1000
  @node_size 5

  # Starts the GenServer and initiates tracing
  def start_link(graph) do
    case Process.whereis(__MODULE__) do
      nil ->
        # IO.puts("#{__MODULE__} No Process running")
        # SigmaGraph.add_node(graph, %{id: "Status", label: "No Process running"}, true)
        GenServer.start_link(__MODULE__, graph, name: __MODULE__)

      # SigmaGraph.add_node(graph, %{id: "Status", label: "Process started"}, true)

      pid when is_pid(pid) ->
        # IO.puts("#{__MODULE__} Process already running #{inspect(pid)}")
        Process.exit(pid, :kill)
        # SigmaGraph.add_node(graph, %{id: "Status", label: "Killing existing Process"}, true)
        # Wait a moment to ensure the process exits
        Process.sleep(100)
        GenServer.start_link(__MODULE__, graph, name: __MODULE__)
        # SigmaGraph.add_node(graph, %{id: "Status", label: "Process started"}, true)
    end
  end

  @impl true
  def init({graph, datatable}) do
    {:ok, %{graph: graph, datatable: datatable}}
  end

  @impl true
  def handle_call(
        {:setup_nodes, node_cnt, custom_pid},
        _from,
        %{graph: graph} = state
      ) do
    pid =
      case is_nil(custom_pid) do
        true -> self()
        false -> custom_pid
      end

    mothership_node_ref = Native.create_node(pid)
    ticket = Native.create_ticket(mothership_node_ref)

    # IO.inspect(ticket, label: "Node1 ticket")

    # connect main node
    # Task.async(fn -> Native.connect_node(mothership_node_ref, ticket) end)
    # Task.async(fn -> Native.connect_node(mothership_node_ref, ticket) end)

    nodes = create_nodes(node_cnt, pid)
    # IO.inspect(nodes, label: "Node list")

    # draw nodes

    Enum.each(nodes, fn node ->
      node_addr = Native.gen_node_addr(node)

      SigmaGraph.add_node(
        graph,
        %{
          id: "#{node_addr}",
          layout: "ring",
          size: @node_size,
          color: "grey",
          label: "#{node_addr}"
        },
        true
      )
    end)

    {:reply, nodes,
     state
     |> Map.put(:ticket, ticket)
     |> Map.put(:mothership_node, mothership_node_ref)
     |> Map.put(:nodes, nodes)
     |> Map.put(:peers, %{})}
  end

  @impl true
  def handle_call(
        {:connect_nodes},
        _from,
        %{graph: graph, ticket: ticket, mothership_node: _mothership_node, nodes: nodes} = state
      ) do
    tasks =
      Enum.map(nodes, fn n ->
        # IO.inspect(n, label: "Connect Node ref")
        node_addr = Native.gen_node_addr(n)

        Task.async(fn ->
          Native.connect_node(n, ticket)

          SigmaGraph.add_node(
            graph,
            %{
              id: "#{node_addr}",
              layout: "ring",
              size: @node_size,
              color: "grey",
              label: "#{node_addr}"
            },
            true
          )
        end)
      end)

    Enum.each(tasks, &Task.await/1)
    {:reply, [], state}
  end

  @impl true
  def handle_call(
        {:send_messages, msg_cnt, use_random_node},
        _from,
        %{graph: graph, ticket: _ticket, mothership_node: _mothership_node, nodes: nodes} = state
      ) do
    no_random_node = Enum.random(nodes)

    msg_sender_receipts =
      1..msg_cnt
      |> Enum.map(fn x ->
        Task.async(fn ->
          node =
            if use_random_node do
              Enum.random(nodes)
            else
              no_random_node
            end

          node_id = Native.gen_node_addr(node)

          rand_msg_delay = :rand.uniform(@rand_msg_delay)
          Process.sleep(rand_msg_delay)

          msg = "MSG:#{x}"
          timestamp = DateTime.utc_now() |> DateTime.to_unix(:millisecond)

          Native.send_message(node, msg)

          SigmaGraph.add_node(
            graph,
            %{id: msg, layout: "grid", size: @node_size, label: msg, color: "grey"},
            true
          )

          # add edge to all pending messages
          target_nodes = nodes -- [node]
          Enum.each(target_nodes, fn n -> 
            node_id = Native.gen_node_addr(n)
            edge = %{source: msg, target: node_id, props: %{ type: "curved", color: "orange" }}
            #IO.inspect(edge, label: "Msg pending edge")
            SigmaGraph.add_edge_batched(graph, edge)
          end)

          SigmaGraph.render(graph)

          receipt = %{
            sender: node_id,
            timestamp: timestamp,
            receipts: []
          }

          {msg, receipt}
        end)
      end)
      |> Enum.map(&Task.await/1)
      |> Map.new()

    msg_receipts =
      msg_sender_receipts
      |> Map.new(fn {msg, _receipt} -> {msg, []} end)

    # IO.puts("#{inspect(msg_receipts)} Final Receipts")
    # IO.puts("#{inspect(msg_sender_receipts)} Final Sender Receipts")

    {:reply, msg_receipts,
     state
     |> Map.put(:msg_sender_receipts, msg_sender_receipts)
     |> Map.put(:msg_receipts, msg_receipts)}
  end

  @impl true
  def handle_call(
        :draw_missing,
        _from,
        %{graph: graph, nodes: nodes, msg_receipts: msg_receipts, datatable: _datatable} = state
      ) do
    node_ids =
      Enum.map(nodes, fn node_ref ->
        Native.gen_node_addr(node_ref)
      end)

    # IO.inspect(node_ids, label: "node ids")
    # IO.inspect(msg_receipts, label: "receipts")

    data = []
    # msg_receipts = []

    Enum.each(msg_receipts, fn {msg, receipts} ->
      # Find missing node IDs

      IO.inspect(receipts, label: "Receipts")
      missing_nodes = node_ids -- receipts

      IO.inspect(missing_nodes, label: "Missing nodes")
      # Enum.map(receipts || [], & &1.sender)

      case missing_nodes do
        [] ->
          IO.puts("All nodes received #{msg}")

          SigmaGraph.add_node(
            graph,
            %{id: msg, layout: "grid", size: @node_size, label: msg, color: "green"},
            true
          )

        _ ->
          SigmaGraph.add_node(
            graph,
            %{
              id: msg,
              layout: "grid",
              size: @node_size,
              label: "Missing nodes: #{Enum.join(missing_nodes, ",")}",
              color: "red"
            },
            true
          )

          IO.puts("Missing nodes #{Enum.join(missing_nodes, ",")} for #{msg}")

          _data = data ++ [%{msg: msg, missing: Enum.join(missing_nodes, ",")}]

          Enum.each(missing_nodes, fn missing_node ->
            # IO.puts("Missing node #{missing_node} for #{msg}")
            SigmaGraph.add_edge(graph, %{source: msg, target: missing_node, props: %{ type: "curved" }})
          end)
      end
    end)

    # Kino.DataTable.update(datatable, data)

    {:reply, [], state}
  end

  def handle_info({:iroh_gossip_neighbor_up, source, target}, %{graph: graph} = state) do
    IO.puts("iroh_gossip_neighbor_up #{source} #{target}")

    state =
      update_in(state.peers, fn peers ->
        updated = Map.update(peers, source, [target], fn peers -> peers ++ [target] end)
        updated
      end)

    peers = Enum.count(state.peers[source])

    color =
      cond do
        peers == 0 -> "grey"
        peers < 3 -> "orange"
        peers >= 3 -> "green"
      end

    SigmaGraph.merge_node(
      graph,
      %{
        id: source,
        layout: "ring",
        size: @node_size + peers * 2,
        color: color,
        label: "#{source} P:#{peers}"
      }
    )

    SigmaGraph.add_edge(graph, %{source: source, target: target})

    {:noreply, state}
  end

  def handle_info({:iroh_gossip_neighbor_down, source, target}, %{graph: graph} = state) do
    IO.puts("iroh_gossip_neighbor_down #{source} #{target}")

    state =
      update_in(state.peers, fn peers ->
        updated = Map.update(peers, source, [], fn peers -> peers -- [target] end)
        updated
      end)

    peers = Enum.count(state.peers[source])

    color =
      cond do
        peers == 0 -> "grey"
        peers < 3 -> "orange"
        peers >= 3 -> "green"
      end

    SigmaGraph.merge_node(
      graph,
      %{
        id: source,
        layout: "ring",
        size: @node_size + peers * 2,
        color: color,
        label: "#{source} P:#{peers}"
      }
    )

    SigmaGraph.remove_edge(graph, %{source: source, target: target})

    {:noreply, state}
  end

  def handle_info({:iroh_gossip_node_discovered, source, target}, %{graph: _graph} = state) do
    # SigmaGraph.add_edge(graph, %{source: source, target: target})
    IO.puts("iroh_gossip_node_discovered #{source} #{target}")
    {:noreply, state}
  end

  def handle_info(
        {:iroh_gossip_message_received, target, msg},
        %{graph: graph} = state
      ) do
    # SigmaGraph.add_edge(graph, %{source: msg, target: target, type: "RECEIVED", color: "green"})

    IO.puts("iroh_gossip_message_received #{target} #{msg}")

    # IO.puts("#{inspect(msg_receipts)} Before update")

    # timestamp = DateTime.utc_now() |> DateTime.to_unix(:millisecond)

    # remove pending edge
    SigmaGraph.remove_edge(graph, %{source: msg, target: target})

    state =
      update_in(state.msg_receipts, fn msg_receipts ->
        updated = Map.update(msg_receipts, msg, [target], fn receipts -> receipts ++ [target] end)
        IO.puts("Updated: #{msg} #{inspect(updated)}")
        updated
      end)

    {:noreply, state}
  end

  @impl true
  def handle_info(msg, state) do
    IO.inspect(msg, label: "#{__MODULE__} handle_info catchall")
    {:noreply, state}
  end

  def create_nodes(node_count, pid) when is_integer(node_count) and node_count > 0 do
    1..node_count
    |> Enum.map(fn _ ->
      Task.async(fn ->
        Native.create_node_async(pid)
      end)
    end)
    # Await results
    |> Enum.map(&Task.await/1)
    |> Enum.reduce([], fn node_ref, acc ->
      case node_ref do
        # Collect valid references
        ref when is_reference(ref) ->
          [ref | acc]

        error ->
          IO.puts("Error creating node: #{inspect(error)}")
          # Skip errors
          acc
      end
    end)
    # |> dbg()
    # Maintain original order
    |> Enum.reverse()
  end
end
```

## Run stuff

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
graph = SigmaGraph.new()

datatable =
  Kino.DataTable.new(
    [],
    keys: [:msg, :missing]
  )

Kino.Layout.grid([graph, datatable], columns: 1)
```

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
# UI Controls
nodes_input = Kino.Input.number("Number of Nodes", default: 10, min: 3)

swarming_delay_input =
  Kino.Input.number("Delay after connect, before sending messages", default: 1000, min: 0)

messages_input = Kino.Input.number("Number of Messages", default: 12, min: 1)
random_sender_input = Kino.Input.checkbox("Use Random Sender", default: true)
start_button = Kino.Control.button("Start Simulation")
reset_button = Kino.Control.button("Reset")
# Display Controls
grid =
  Kino.Layout.grid([
    nodes_input,
    swarming_delay_input,
    messages_input,
    random_sender_input,
    start_button,
    reset_button
  ])

defmodule IrohLogger do
  use GenServer
  @impl true
  def init(init_arg) do
    {:ok, init_arg}
  end

  @impl true
  def handle_info(msg, state) do
    IO.puts("Catchall #{inspect(msg)}")
    {:noreply, state}
  end
end

grid
```

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir

num_nodes = Kino.Input.read(nodes_input)
  num_messages = Kino.Input.read(messages_input)
  use_random = Kino.Input.read(random_sender_input)
  delay_ms = Kino.Input.read(swarming_delay_input)

Kino.listen(reset_button, fn _event -> 
  SigmaGraph.clear(graph)
end)

Kino.listen(start_button, fn _event ->

  SigmaGraph.clear(graph)
  {:ok, logger_pid} = GenServer.start_link(IrohLogger, nil)
  {:ok, observer_pid} = IrohObserver.start_link({graph, datatable})

  IO.inspect(%{logger_pid: logger_pid, observer_pid: observer_pid}, label: "Pids")

  # Use "dummy" logger
  # GenServer.call(observer_pid, {:setup_nodes, num_nodes, logger_pid}, 30_000)

  # Use IrohObserver, pid == nil means self()
  GenServer.call(observer_pid, {:setup_nodes, num_nodes, nil}, 30_000)
  # Connect nodes
  GenServer.call(observer_pid, {:connect_nodes}, 60_000)
  Process.sleep(delay_ms)

  # Send messages
  GenServer.call(observer_pid, {:send_messages, num_messages, use_random}, 60_000)

  {:messages, messages} = :erlang.process_info(self(), :messages)

  IO.inspect(messages, label: "Inbox")

  # Final graph update visualizing pending deliveries
  #GenServer.call(observer_pid, :draw_missing)
end)

```
